import 'dart:io';
import 'package:path_provider/path_provider.dart';
import 'package:shelf/shelf.dart';
import 'package:shelf_router/shelf_router.dart';
import 'package:shelf_multipart/shelf_multipart.dart';
import 'package:shelf/shelf_io.dart' as shelf_io;
import 'package:mime/mime.dart';

class SimpleHttpServer {
  HttpServer? _server;
  int _port = 8080;
  Directory? _appDir;

  // é»˜è®¤å¯åŠ¨æœåŠ¡å™¨ç›‘å¬ 0.0.0.0
  Future<String> start({int port = 8080}) async {
    _appDir = await getApplicationDocumentsDirectory();
    _port = port;

    final router = Router();

    // ---------- é¦–é¡µ ----------
    router.get('/', (Request request) {
      final files = _appDir!.listSync().whereType<File>().toList();

      final fileListHtml = files.map((f) {
        final name = f.uri.pathSegments.last;
        final encodedName = Uri.encodeComponent(name);
        final mimeType = lookupMimeType(f.path) ?? 'application/octet-stream';

        String icon;
        if (mimeType.startsWith('video/')) {
          icon = 'ğŸ¬';
        } else if (mimeType.startsWith('image/')) {
          icon = 'ğŸ–¼ï¸';
        } else if (mimeType.startsWith('text/') || mimeType == 'application/pdf') {
          icon = 'ğŸ“„';
        } else {
          icon = 'ğŸ“¦';
        }

        final actionLink = mimeType.startsWith('video/')
            ? 'javascript:playVideo("$encodedName")'
            : '/$encodedName';

        return '''
<li class="list-group-item d-flex justify-content-between align-items-center">
  <span>
    <span style="margin-right:0.5rem;">$icon</span>
    <a href="$actionLink">$name</a>
  </span>
  <form method="POST" action="/delete?file=$encodedName" onsubmit="return confirm('ç¡®å®šåˆ é™¤ $name å—ï¼Ÿ');">
    <button class="btn btn-sm btn-danger">åˆ é™¤</button>
  </form>
</li>
''';
      }).join('');

      final html = '''
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>æ–‡ä»¶ä¸Šä¼ /ä¸‹è½½</title>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/shaka-player/4.4.0/shaka-player.compiled.js"></script>
<style>
body { padding: 2rem; }
h2 { margin-top: 2rem; }
.file-list { max-width: 700px; margin-top: 1rem; }
#video-container { margin-top: 2rem; max-width: 700px; }
</style>
</head>
<body>
<div class="container">
<h2>ä¸Šä¼ æ–‡ä»¶</h2>
<form method="POST" action="/upload" enctype="multipart/form-data" class="mb-4">
  <div class="input-group">
    <input type="file" name="file" class="form-control" required>
    <button type="submit" class="btn btn-primary">ä¸Šä¼ </button>
  </div>
</form>

<h2>å·²ä¸Šä¼ æ–‡ä»¶</h2>
<ul class="list-group file-list">
$fileListHtml
</ul>

<div id="video-container">
  <video id="video" width="640" controls style="display:none"></video>
</div>

<script>
document.addEventListener('DOMContentLoaded', async () => {
  const video = document.getElementById('video');
  const player = new shaka.Player(video);

  player.addEventListener('error', e => console.error('Shaka Player error', e.detail));

  window.playVideo = async (encodedFileName) => {
    const url = '/' + encodedFileName; // ç›´æ¥ç”¨ /filename.mp4
    try {
      await player.load(url);
      video.style.display = 'block';
      video.scrollIntoView({behavior: 'smooth'});
      if (video.requestFullscreen) video.requestFullscreen();
      video.play();
    } catch (e) {
      console.error('è§†é¢‘æ’­æ”¾å¤±è´¥', e);
      alert('è§†é¢‘æ’­æ”¾å¤±è´¥');
    }
  };
});
</script>
</div>
</body>
</html>
''';

      return Response.ok(html, headers: {'Content-Type': 'text/html'});
    });

    // ---------- ä¸Šä¼ ï¼ˆæµå¼å†™å…¥å¤§æ–‡ä»¶ï¼‰ ----------
    router.post('/upload', (Request request) async {
      final multipart = request.multipart();
      if (multipart != null) {
        await for (final part in multipart.parts) {
          if (part.headers['content-disposition']?.contains('filename') == true) {
            final filename = part.headers['content-disposition']!
                .split(';')
                .firstWhere((e) => e.trim().startsWith('filename'))
                .split('=')
                .last
                .trim()
                .replaceAll('"', '');

            final file = File('${_appDir!.path}/$filename');
            final sink = file.openWrite();
            await part.pipe(sink);
            await sink.flush();
            await sink.close();
          }
        }
        return Response.ok('<p>ä¸Šä¼ æˆåŠŸï¼<a href="/">è¿”å›é¦–é¡µ</a></p>',
            headers: {'Content-Type': 'text/html'});
      } else {
        return Response(400, body: 'æ— æ•ˆä¸Šä¼ è¯·æ±‚');
      }
    });

    // ---------- åˆ é™¤ ----------
    router.post('/delete', (Request request) async {
      final filenameParam = request.url.queryParameters['file'];
      if (filenameParam == null) return Response(400, body: 'ç¼ºå°‘æ–‡ä»¶å');

      final filename = Uri.decodeComponent(filenameParam);
      final file = File('${_appDir!.path}/$filename');

      if (!file.existsSync()) return Response(404, body: 'æ–‡ä»¶æœªæ‰¾åˆ°');

      try {
        await file.delete();
        return Response.ok('<p>åˆ é™¤æˆåŠŸï¼<a href="/">è¿”å›é¦–é¡µ</a></p>',
            headers: {'Content-Type': 'text/html'});
      } catch (e) {
        return Response(500, body: 'åˆ é™¤å¤±è´¥: $e');
      }
    });

    // ---------- æ–‡ä»¶è®¿é—®ï¼ˆæ”¯æŒ Rangeï¼Œç›´æ¥ /filename.xxxï¼‰ ----------
    router.get('/<filename|.*>', (Request request, String filename) async {
      final decodedName = Uri.decodeComponent(filename);
      final file = File('${_appDir!.path}/$decodedName');

      if (!file.existsSync()) return Response.notFound('æ–‡ä»¶æœªæ‰¾åˆ°');

      final fileLength = await file.length();
      final rangeHeader = request.headers['range'];
      final mimeType = lookupMimeType(file.path) ?? 'application/octet-stream';
      final contentDisposition =
          mimeType.startsWith('video/') ? 'inline' : 'attachment';

      if (rangeHeader != null && rangeHeader.startsWith('bytes=')) {
        final parts = rangeHeader.substring(6).split('-');
        final start = int.parse(parts[0]);
        final end = parts[1].isNotEmpty ? int.parse(parts[1]) : fileLength - 1;
        final length = end - start + 1;
        final stream = file.openRead(start, end + 1);

        return Response(HttpStatus.partialContent,
            body: stream,
            headers: {
              'Content-Type': mimeType,
              'Content-Range': 'bytes $start-$end/$fileLength',
              'Content-Length': length.toString(),
              'Accept-Ranges': 'bytes',
              'Content-Disposition': '$contentDisposition; filename="$decodedName"',
            });
      }

      return Response.ok(file.openRead(), headers: {
        'Content-Type': mimeType,
        'Content-Length': fileLength.toString(),
        'Content-Disposition': '$contentDisposition; filename="$decodedName"',
        'Accept-Ranges': 'bytes',
      });
    });

    final handler = const Pipeline().addMiddleware(logRequests()).addHandler(router);
    _server = await shelf_io.serve(handler, InternetAddress.anyIPv4, _port);

    return 'http://${_server!.address.address}:$_port';
  }

  Future<void> stop() async {
    await _server?.close(force: true);
    _server = null;
  }
}
