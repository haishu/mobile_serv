import 'dart:io';
import 'package:path_provider/path_provider.dart';
import 'package:shelf/shelf.dart';
import 'package:shelf_router/shelf_router.dart';
import 'package:shelf_multipart/shelf_multipart.dart';
import 'package:shelf/shelf_io.dart' as shelf_io;
import 'package:mime/mime.dart';

class SimpleHttpServer {
  HttpServer? _server;
  int _port = 8080;
  Directory? _appDir;

  // 默认启动服务器监听 0.0.0.0
  Future<String> start({int port = 8080}) async {
    _appDir = await getApplicationDocumentsDirectory();
    _port = port;

    final router = Router();

    // ---------- 首页 ----------
    router.get('/', (Request request) {
      final files = _appDir!.listSync().whereType<File>().toList();

      final fileListHtml = files.map((f) {
        final name = f.uri.pathSegments.last;
        final encodedName = Uri.encodeComponent(name);
        final mimeType = lookupMimeType(f.path) ?? 'application/octet-stream';

        String icon;
        if (mimeType.startsWith('video/')) {
          icon = '🎬';
        } else if (mimeType.startsWith('image/')) {
          icon = '🖼️';
        } else if (mimeType.startsWith('text/') || mimeType == 'application/pdf') {
          icon = '📄';
        } else {
          icon = '📦';
        }

        final actionLink = mimeType.startsWith('video/')
            ? 'javascript:playVideo("$encodedName")'
            : '/$encodedName';

        return '''
<li class="list-group-item d-flex justify-content-between align-items-center">
  <span>
    <span style="margin-right:0.5rem;">$icon</span>
    <a href="$actionLink">$name</a>
  </span>
  <form method="POST" action="/delete?file=$encodedName" onsubmit="return confirm('确定删除 $name 吗？');">
    <button class="btn btn-sm btn-danger">删除</button>
  </form>
</li>
''';
      }).join('');

      final html = '''
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>文件上传/下载</title>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/shaka-player/4.4.0/shaka-player.compiled.js"></script>
<style>
body { padding: 2rem; }
h2 { margin-top: 2rem; }
.file-list { max-width: 700px; margin-top: 1rem; }
#video-container { margin-top: 2rem; max-width: 700px; }
</style>
</head>
<body>
<div class="container">
<h2>上传文件</h2>
<form method="POST" action="/upload" enctype="multipart/form-data" class="mb-4">
  <div class="input-group">
    <input type="file" name="file" class="form-control" required>
    <button type="submit" class="btn btn-primary">上传</button>
  </div>
</form>

<h2>已上传文件</h2>
<ul class="list-group file-list">
$fileListHtml
</ul>

<div id="video-container">
  <video id="video" width="640" controls style="display:none"></video>
</div>

<script>
document.addEventListener('DOMContentLoaded', async () => {
  const video = document.getElementById('video');
  const player = new shaka.Player(video);

  player.addEventListener('error', e => console.error('Shaka Player error', e.detail));

  window.playVideo = async (encodedFileName) => {
    const url = '/' + encodedFileName; // 直接用 /filename.mp4
    try {
      await player.load(url);
      video.style.display = 'block';
      video.scrollIntoView({behavior: 'smooth'});
      if (video.requestFullscreen) video.requestFullscreen();
      video.play();
    } catch (e) {
      console.error('视频播放失败', e);
      alert('视频播放失败');
    }
  };
});
</script>
</div>
</body>
</html>
''';

      return Response.ok(html, headers: {'Content-Type': 'text/html'});
    });

    // ---------- 上传（流式写入大文件） ----------
    router.post('/upload', (Request request) async {
      final multipart = request.multipart();
      if (multipart != null) {
        await for (final part in multipart.parts) {
          if (part.headers['content-disposition']?.contains('filename') == true) {
            final filename = part.headers['content-disposition']!
                .split(';')
                .firstWhere((e) => e.trim().startsWith('filename'))
                .split('=')
                .last
                .trim()
                .replaceAll('"', '');

            final file = File('${_appDir!.path}/$filename');
            final sink = file.openWrite();
            await part.pipe(sink);
            await sink.flush();
            await sink.close();
          }
        }
        return Response.ok('<p>上传成功！<a href="/">返回首页</a></p>',
            headers: {'Content-Type': 'text/html'});
      } else {
        return Response(400, body: '无效上传请求');
      }
    });

    // ---------- 删除 ----------
    router.post('/delete', (Request request) async {
      final filenameParam = request.url.queryParameters['file'];
      if (filenameParam == null) return Response(400, body: '缺少文件名');

      final filename = Uri.decodeComponent(filenameParam);
      final file = File('${_appDir!.path}/$filename');

      if (!file.existsSync()) return Response(404, body: '文件未找到');

      try {
        await file.delete();
        return Response.ok('<p>删除成功！<a href="/">返回首页</a></p>',
            headers: {'Content-Type': 'text/html'});
      } catch (e) {
        return Response(500, body: '删除失败: $e');
      }
    });

    // ---------- 文件访问（支持 Range，直接 /filename.xxx） ----------
    router.get('/<filename|.*>', (Request request, String filename) async {
      final decodedName = Uri.decodeComponent(filename);
      final file = File('${_appDir!.path}/$decodedName');

      if (!file.existsSync()) return Response.notFound('文件未找到');

      final fileLength = await file.length();
      final rangeHeader = request.headers['range'];
      final mimeType = lookupMimeType(file.path) ?? 'application/octet-stream';
      final contentDisposition =
          mimeType.startsWith('video/') ? 'inline' : 'attachment';

      if (rangeHeader != null && rangeHeader.startsWith('bytes=')) {
        final parts = rangeHeader.substring(6).split('-');
        final start = int.parse(parts[0]);
        final end = parts[1].isNotEmpty ? int.parse(parts[1]) : fileLength - 1;
        final length = end - start + 1;
        final stream = file.openRead(start, end + 1);

        return Response(HttpStatus.partialContent,
            body: stream,
            headers: {
              'Content-Type': mimeType,
              'Content-Range': 'bytes $start-$end/$fileLength',
              'Content-Length': length.toString(),
              'Accept-Ranges': 'bytes',
              'Content-Disposition': '$contentDisposition; filename="$decodedName"',
            });
      }

      return Response.ok(file.openRead(), headers: {
        'Content-Type': mimeType,
        'Content-Length': fileLength.toString(),
        'Content-Disposition': '$contentDisposition; filename="$decodedName"',
        'Accept-Ranges': 'bytes',
      });
    });

    final handler = const Pipeline().addMiddleware(logRequests()).addHandler(router);
    _server = await shelf_io.serve(handler, InternetAddress.anyIPv4, _port);

    return 'http://${_server!.address.address}:$_port';
  }

  Future<void> stop() async {
    await _server?.close(force: true);
    _server = null;
  }
}
